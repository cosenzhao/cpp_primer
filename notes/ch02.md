# 第二章 变量和基本类型

### 基本内置类型
 
**基本算数类型**：

| 类型 | 含义 | 最小尺寸|
|---|---|---|
| `bool` | 布尔类型  | 8bits |
| `char`| 字符 | 8bits |
| `wchar_t` | 宽字符 | 16bits |
| `char16_t` | Unicode字符 | 16bits |
| `char32_t` | Unicode字符 | 32bits |
| `short` | 短整型 | 16bits |
| `int` | 整型 | 16bits (在32位机器中是32bits) |
| `long` | 长整型 | 32bits |
| `long long` | 长整型 | 64bits （是在C++11中新定义的） |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |


### 如何选择类型

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`。
- 4.浮点运算选用`double`。

### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。

### 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  - 整型和浮点型字面值。
  > 数值20的几种表示形式   
     &ensp;&ensp; &ensp;  20  &ensp;&ensp; &ensp; 十进制  
     &ensp;&ensp; &ensp;  024  &ensp;&ensp; &ensp; 八进制  
     &ensp;&ensp; &ensp;  0x14  &ensp;&ensp; &ensp; 十六进制
  
  形如-42的负十进制字面值，负号并不在字面值之内，作用仅仅是对字面值取符号而已
  - 字符和字符串字面值。
    - 使用空格连接，继承自C。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World""` 字符串实际是由常量字符构成的数组，编译器在每个字符串的结尾添加一个空字符`\0`，因此，字符串字面值实际长度要比它的内容多1。
  - 转义序列。`\n`、`\t`等。
  - 布尔字面值。`true`，`false`。
  - 指针字面值。`nullptr`  

**字符和字符串字面值**  
| 前缀 | 含义 | 类型 |
|---|---|---|
|u|Unicode16 字符|char16_t|
|U|Unicode 32 字符|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8(仅用于字符串字面常量)|char|

| 整型字面值 |  |  浮点型字面值|   |  
|---|---|---|---|
|后缀|最小匹配类型|后缀|类型|
|u or U|long|f或F|float|
|l or L|long|l或L|long double|
|ll or LL|long long|

## 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。   `C++`中**变量**和**对象**一般可以互换使用。

### 变量定义（define）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
- **初始化**（initialize）：对象在创建时获得了一个特定的值。
  - **初始化不是赋值！**：
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替
  - **列表初始化**：使用花括号`{}`，如`int units_sold{0};`
  - 默认初始化：定义时没有指定初始值会被默认初始化；在函数体内部的内置类型变量将不会被初始化。
  - 建议初始化每一个内置类型的变量。  
  
  * 列表初始化且初始值存在丢失信息的风险，则编译器将报错，如
    >long double ld = 3.1415926536  
    int a{ld},&ensp;a={ld};&ensp;//错误：转换未执行，因为存在丢失信息的风险  
    int c(ld),&ensp;d=ld;&ensp;// 正确：转换执行，且确实丢失了部分值

### 变量的**声明**（declaration） vs **定义**（define）
  - 为了支持分离式编译，`C++`将声明和定义区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体。
  - **extern**：只是说明变量定义在其他地方。
  - 只声明而不定义： 在变量名前添加关键字 `extern`，如`extern int i;`。但如果包含了初始值，就变成了定义：`extern double pi = 3.14;`
  - 变量只能被定义一次，但是可以多次声明。
- 名字的**作用域**（namescope）

## 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。


## 复合类型

### 引用

- **引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如`int &refVal = val;`。
- 引用必须初始化。
- 引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。
- 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

### 指针

- 是一种 `"指向（point to）"`另外一种类型的复合类型。
- **定义**指针类型： `int *ip1;`，**从右向左读**，`ip1`是指向`int`类型的指针。
- 指针存放某个对象的**地址**。
- 获取对象的地址： `int i=42; int *p = &i;`。 `&`是**取地址符**。
- 指针的值的四种状态：
  - 1.指向一个对象；
  - 2.指向紧邻对象的下一个位置；
  - 3.空指针；
  - 4.无效指针。
- 指针访问对象： `cout << *p;`， `*`是**解引用符**。
- 空指针不指向任何对象。
- `void*`指针可以存放**任意**对象的地址。
- 其他指针类型必须要与所指对象**严格匹配**。
- 两个指针相减的类型是`ptrdiff_t`。
- 建议：初始化所有指针。
### **空指针**
**空指针**不指向任何对象   

>int *p1 = nullptr;  //等价于int *p =0；
int *p2 = 0;  
//需要首先include cstdlib  
int *p3 = NULL; //等价于int *p =0；  

### 赋值和指针
> 赋值永远改变的是等号左侧的对象，如：  
pi = &ival;  &ensp;&ensp; //pi的值被改变，现在pi指向了ival  
*pi =0 ;ival的值被改变，指针pi并没有改变  

### void*指针  
void* 是一种特殊的指针类型，可用于存放任意对象的地址。  

### 指向指针的指针
>  **表示指向指针的指针  
### 指向指针的引用  
> int i =42  
int *p; &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; //p是一个int型指针  
int *&r =p; &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;  //r是一个对指针p的引用  
r = &i; &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; //r引用了一个指针，因此给r赋值&i就是令p指向i  
*r = 0； &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; //解引用r得到也就是p指向的对象，将i的值改为0

## const限定符

- 动机：希望定义一些不能被改变值的变量。

### 初始化和const
- const对象**必须初始化**，且**不能被改变**。
- const变量默认不能被其他文件访问，非要访问，必须在指定const前加extern。

### const的引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
- **临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。
- 对临时量的引用是非法行为。
### 赋值和指针

### 指针和const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = &pi;`。
- **const pointer**：指针本身是常量，如 `int i = 0; int *const ptr = &i;`

### 顶层const

- `顶层const`：指针本身是个常量。
- `底层const`：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。

### `constexpr`和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。

## 处理类型

### 类型别名

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）

### auto类型说明符

- **auto**类型说明符：让编译器**自动推断类型**。
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，需要自己加`const`
- `C++11`

### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- `C++11`

## 自定义数据结构

### struct

- 类可以以关键字`struct`开始，紧跟类名和类体。
- 类数据成员：类体定义类的成员。
- `C++11`：可以为类数据成员提供一个**类内初始值**（in-class initializer）。

### 编写自己的头文件

- 头文件通常包含哪些只能被定义一次的实体：类、`const`和`constexpr`变量。

预处理器概述：

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。
- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`
- **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```
